package exploit

import (
	"bufio"
	"crypto/sha1"
	"encoding/hex"
	"encoding/json"
	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/sts"
	"github.com/intuit/gitdetect/rule"
	"log"
	"os"
	"regexp"
	"sync"
)

//AWSInfo AWS STS data returned by by exploit function awsSTS
type AWSInfo struct {
	Account string
	Arn     string
	UserID  string
}

type awsExploiter interface {
	AccessAWS(keyID, keySecret string) *AWSInfo
}

//An awsExploiter and AWSCredentialsProvider implementation
type stsCredentials struct {
	KeyID     string //used to implement the provider interface
	KeySecret string //used to implement the provider interface
}

var keyIDRule *rule.Rule
var uniqueExploitedCredentials sync.Map
var awsexploiter awsExploiter

func init() {
	//regex for AWS key id
	keyIDRule = getRule([]string{`\"(?P<suspect>A[A-Z0-9\/+]{19})\"`, `'(?P<suspect>A[A-Z0-9\/+]{19})'`})
	SetAWSExploiter(stsCredentials{}) //set as implementation type therefore this single instance is not relied upon for  its state.  State is used when creating new STSCredential instance.
}

//SetAWSExploiter is used to set, either the stsCredentials provider used to access AWS or the mock test implementation
func SetAWSExploiter(exploiter awsExploiter) {
	awsexploiter = exploiter
}

//AwsSTS Hook function configuration, ExploitFn
func (exploit *Exploit) AwsSTS() (err error) {
	fh, err := os.Open(exploit.Filename)

	if err != nil {
		log.Printf("Error opening file %s, %s", exploit.Filename, err.Error())
		return // there was a problem opening the file.
	}
	scanner := bufio.NewScanner(fh)
	defer fh.Close()

	for scanner.Scan() {

		text := scanner.Text()

		if matches, found := keyIDRule.Match(text); found {
			for _, match := range matches {
				stsCredentials := stsCredentials{KeyID: match, KeySecret: exploit.Secret}

				//avoid reexploitation
				if exploitOutput, res := previouslyExploited(stsCredentials); res {
					exploit.Output = exploitOutput
					return
				}
				if callerIDOutput := awsexploiter.AccessAWS(stsCredentials.KeyID, stsCredentials.KeySecret); callerIDOutput != nil {
					exploit.Output = identityOutputToJSON(callerIDOutput)
					uniqueExploitedCredentials.Store(stsCredentials.hash(), exploit.Output)
					return
				}
			}
		}
	}

	return
}

//AccessAWS returns nil if access fails.  This is the stsCredentials awsExploiter implementation
func (this stsCredentials) AccessAWS(keyID, keySecret string) (awsInfo *AWSInfo) {

	awsStsSession := sts.New(session.Must(session.NewSession()))

	//this is a copy so when can use it as a unique creds provicer
	provider := stsCredentials{KeyID: keyID, KeySecret: keySecret}

	creds := credentials.NewCredentials(&provider)
	awsStsSession.Config.WithCredentials(creds)

	stsCallerIdentity, err := awsStsSession.GetCallerIdentity(&sts.GetCallerIdentityInput{})
	if err == nil {
		awsInfo = &AWSInfo{Account: *stsCallerIdentity.Account, Arn: *stsCallerIdentity.Arn, UserID: *stsCallerIdentity.UserId}
	}

	return
}

//Retrieve must be implemented to honor the AWS Credentials Provider interface
func (this *stsCredentials) Retrieve() (value credentials.Value, err error) {
	value.SecretAccessKey = this.KeySecret
	value.AccessKeyID = this.KeyID
	return
}

//IsExpired must be implemented to honor the AWS Credentials Provider interface
func (this *stsCredentials) IsExpired() bool {
	return false
}
func identityOutputToJSON(awsInfo *AWSInfo) (awsInfoJSON string) {

	jsonBytes, err := json.Marshal(*awsInfo)
	if err == nil {
		awsInfoJSON = string(jsonBytes)
	}
	return
}

func previouslyExploited(stsCredentials stsCredentials) (exploitOutput string, alreadyExploited bool) {
	if output, found := uniqueExploitedCredentials.Load(stsCredentials.hash()); found {
		return output.(string), true
	}
	return "", false
}

func getRule(regExRules []string) *rule.Rule {

	var compiledRegExs []*regexp.Regexp
	for _, regEx := range regExRules {
		compiledRegEx, err := regexp.Compile(regEx)
		if err != nil {
			log.Fatal("Illegal golang regexp " + err.Error())
		}
		compiledRegExs = append(compiledRegExs, compiledRegEx)

	}
	return &rule.Rule{Target: compiledRegExs}
}

func (this *stsCredentials) hash() string {
	secretHash := sha1.New().Sum([]byte(this.KeySecret + this.KeyID))
	return hex.EncodeToString(secretHash)
}
